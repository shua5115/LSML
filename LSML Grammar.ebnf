(* EBNF Grammar for LSML *)

(* String convention: 'literal string' "C-style string, handles escape characters" *)
(* NOTE: using '-' operator to denote an exception to a set of values *)

lsml ::= { {whitespace | endline} section } {whitespace | endline}

section ::= table | array

table ::= '{' table-name '}' endline
    { {endline} key '=' value endline }

array ::= '[' array-name ']' endline
    (* CSV row must end with a string value followed by optional trailing comma and an endline *)
    { {endline} {value-no-comma ',' } value-no-comma [','] {whitespace} endline }


(* NOTE: Checking for the start of a table or array takes precedence over parsing a string at the beginning of a line *)
table-name ::=      {whitespace} [ref-prefix] {whitespace} (quoted-string | escaped-string | unquoted-string-except-brace) {whitespace}
array-name ::=      {whitespace} [ref-prefix] {whitespace} ("''" | '""' | "``" | quoted-string | escaped-string | unquoted-string-except-bracket) {whitespace}
key ::=             {whitespace} [ref-prefix] {whitespace} ("''" | '""' | "``" | quoted-string | escaped-string | unquoted-string-except-equals) {whitespace}
value ::=           {whitespace} [ref-prefix] {whitespace} ["''" | '""' | "``" | quoted-string | escaped-string | unquoted-string] {whitespace}
value-no-comma ::=  {whitespace} [ref-prefix] {whitespace} ["''" | '""' | "``" | quoted-string | escaped-string | unquoted-string-except-comma] {whitespace}


byte ::= ? any integer in range 0 to 255, inclusive, interpreted as a character in a utf8 string ?
endline ::= {whitespace} [comment] newline
newline ::= "\n"
whitespace ::= ' ' | "\t"
not-newline ::= byte - newline
comment ::= '#' {not-newline}
ref-prefix ::= "{}" | "[]"


(* all unquoted strings are trimmed of whitespace on either end after parsing *)
unquoted-string ::= not-newline {not-newline}
unquoted-string-except-brace ::= (not-newline - '}') { not-newline - '}' }
unquoted-string-except-bracket ::= (not-newline - ']') { not-newline - ']' }
unquoted-string-except-equals ::= (not-newline - '=') { not-newline - '=' }
unquoted-string-except-comma ::= (not-newline - ',') { not-newline - ',' }

(* quoted strings can contain any character except a newline or end quote *)
quoted-string ::= single-quoted-string | double-quoted-string
single-quoted-string ::= "'" not-newline-or-single-quote {not-newline-or-single-quote} "'"
double-quoted-string ::= '"' not-newline-or-double-quote {not-newline-or-double-quote} '"'
not-newline-or-single-quote ::= (not-newline - "'")
not-newline-or-double-quote ::= (not-newline - '"')

(* escaped strings handle C-style escape sequences *)
escaped-string ::= '`' not-newline-or-backtick-escapable {not-newline-or-backtick-escapable} '`'
not-newline-or-backtick-escapable ::= (not-newline - '`') | escape-sequence

escape-sequence ::= char-escape | hex-escape | oct-escape | utf16-escape | utf32-escape
char-escape ::= '\' escapable
    escapable ::= 'n' | 'a' | 'b' | 't' | 'f' | 'r' | 'v' | '\' | "'" | '"' | '?'
oct-escape ::= '\' oct-digit [oct-digit] [oct-digit]
hex-escape ::= '\x' hex-digit [hex-digit]
utf16-escape ::= '\u' hex-digit hex-digit hex-digit hex-digit (*should be a valid unicode codepoint*)
utf32-escape ::= '\U' hex-digit hex-digit hex-digit hex-digit hex-digit hex-digit hex-digit hex-digit (*should be a valid unicode codepoint*)

bin-digit ::= '0' | '1'
oct-digit ::= bin-digit | '2' | '3' | '4' | '5' | '6' | '7'
dec-digit ::= oct-digit | '8' | '9'
hex-digit ::= dec-digit | 'A' | 'a' | 'B' | 'b' | 'C' | 'c' | 'D' | 'd' | 'E' | 'e' | 'F' | 'f'


(* Interpreting Parsed Strings *)

section-reference ::= {whitespace} ref-prefix {byte} (* The sequence of {byte} is the parsed name of the referenced section *)

(* Integer and Float parsing should follow similar rules to the C standard *)
integer ::= dec-integer | hex-integer | oct-integer | bin-integer
    dec-integer ::= ['-'] dec-digit {dec-digit}
    hex-integer ::= ("0x" | "0X") hex-digit {hex-digit}
    oct-integer ::= ("0o" | "0O") oct-digit {oct-digit}
    bin-integer ::= ("0b" | "0B") bin-digit {bin-digit}
float ::= ['-'|'+'] float-mantissa [('e' | 'E') ['-'|'+'] dec-digit {dec-digit}]
    float-mantissa ::= (dec-digit {dec-digit} ['.'] {dec-digit}) | ('.' dec-digit {dec-digit})

(* Booleans should only be considered valid if they are one of these strings exactly *)
boolean ::= true | false
    true ::= "true" | "True" | "TRUE"
    false ::= "false" | "False" | "FALSE"